import org.springframework.boot.gradle.plugin.SpringBootPlugin

plugins {
  id 'java'
  
  alias libs.plugins.spring.boot
  alias libs.plugins.spring.dependency.management
  
  alias libs.plugins.lombok
  alias libs.plugins.springdoc.openapi
  alias libs.plugins.liquibase
  
  id 'jacoco'
  alias libs.plugins.sonarqube
  
  alias libs.plugins.docker.compose

  alias libs.plugins.spotless

  alias libs.plugins.axion.release
}

group = 'org.sitmun'

java {
  toolchain {
    languageVersion = JavaLanguageVersion.of(17)
  }
}

repositories {
  mavenLocal()
  mavenCentral()
}

dependencyManagement {
  imports {
    mavenBom SpringBootPlugin.BOM_COORDINATES
  }
}

def packaging = (project.findProperty('packaging') ?: 'jar')

if (packaging == 'war') {
  apply plugin: 'war'
}

dependencies {

  // If packaging as WAR, use provided Tomcat runtime
  if (packaging == 'war') {
    providedRuntime libs.spring.boot.starter.tomcat
  }

  // Data persistence and REST API
  implementation libs.spring.boot.starter.data.jpa
  implementation libs.spring.boot.starter.data.rest
  
  // Security and validation
  implementation libs.spring.boot.starter.security
  implementation libs.spring.boot.starter.validation
  
  // Monitoring and templating
  implementation libs.spring.boot.starter.actuator
  implementation libs.spring.boot.starter.thymeleaf
  
  // Development and testing database
  implementation libs.h2
  
  // Production databases
  implementation libs.postgresql
  implementation libs.oracle.jdbc

  // Database migration
  implementation libs.liquibase.core
  
  // Query building
  implementation variantOf(libs.querydsl.jpa) { classifier('jakarta') }
  
  // Object mapping
  implementation libs.mapstruct

  // Apache Commons utilities
  implementation libs.commons.lang3
  
  // Google Guava utilities
  implementation libs.guava

  // OkHttp client with logging
  implementation platform(libs.okhttp.bom)
  implementation libs.okhttp
  implementation libs.okhttp.logging

  // JSON processing
  implementation libs.json
  
  // JWT token handling
  implementation libs.jjwt.api
  implementation libs.jjwt.impl
  implementation libs.jjwt.jackson

  // OIDC support
  implementation libs.spring.boot.starter.oauth2.client

  // OpenAPI/Swagger documentation
  implementation libs.springdoc.openapi.starter.webmvc.ui

  // LDAP profile
  implementation libs.spring.ldap.core
  implementation libs.spring.security.ldap

  // Mail profile
  implementation libs.spring.boot.starter.mail

  // Rate limiting
  implementation libs.bucket4j.core

  // Core annotation processing
  annotationProcessor libs.jakarta.annotation.api
  annotationProcessor libs.spring.boot.configuration.processor
  annotationProcessor libs.jakarta.persistence.api
  
  // QueryDSL code generation
  annotationProcessor variantOf(libs.querydsl.apt) { classifier('jakarta') }
  
  // MapStruct code generation
  annotationProcessor libs.mapstruct.processor

  // Development-time annotations
  compileOnly libs.jetbrains.annotations

  // Spring Boot test support
  testImplementation(libs.spring.boot.starter.test) {
    exclude group: 'com.vaadin.external.google', module: 'android-json'
  }
  
  // Security testing
  testImplementation libs.spring.security.test
  
  // Testing utilities
  testImplementation libs.hamcrest
  
  // LDAP testing (embedded LDAP server)
  testImplementation libs.unboundid.ldapsdk

}

// ============================================================================
// TESTING AND QUALITY ASSURANCE CONFIGURATION
// ============================================================================
// 
// Database Testing with Docker Compose Plugin
// ------------------------------------------
// The project uses the Gradle Docker Compose plugin for PostgreSQL testing.
// This provides automatic container lifecycle management with health checks.
// 
// Available tasks:
// - testPostgres: Run tests with PostgreSQL (automatically starts/stops container)
// - startPostgresTest: Start PostgreSQL container manually
// - stopPostgresTest: Stop PostgreSQL container manually  
// - cleanPostgresTest: Clean up containers and volumes
// 
// Configuration: docker/test-postgres-compose.yml
// ============================================================================

// Test configuration
tasks.withType(Test).configureEach {
  useJUnitPlatform()
  maxHeapSize = '2G'
  minHeapSize = '512m'

  // Reduce forking to improve performance - only fork when necessary
  forkEvery = 0
  
  // Memory settings for test JVM
  jvmArgs '-Xmx2g', '-Xms512m', '-XX:+UseG1GC', '-XX:MaxGCPauseMillis=200', '-XX:+UseStringDeduplication'
  
  // Set system properties for test JVM
  systemProperty 'spring.profiles.active', 'test,h2'
  systemProperty 'java.awt.headless', 'true'
  
  // Test logging
  testLogging {
    events "passed", "skipped", "failed"
    exceptionFormat = 'full'
  }
}

// H2 Database Tests (default)
tasks.register('testH2', Test) {
  group = 'verification'
  description = 'Run tests with H2 in-memory database'
  
  testLogging {
    events "passed", "skipped", "failed"
    exceptionFormat = 'full'
  }
}

// PostgreSQL Database Tests
tasks.register('testPostgres', Test) {
  group = 'verification'
  description = 'Run tests with PostgreSQL database using Docker Compose'
  systemProperty 'spring.profiles.active', 'postgres'
  testLogging {
    events "passed", "skipped", "failed"
    exceptionFormat = 'full'
  }
  doFirst {
    sleep(5000) // Wait for Postgres container to be ready
  }
}

tasks.register('testOracle', Test) {
  group = 'verification'
  description = 'Run tests with OracleSQL database using Docker Compose'
  systemProperty 'spring.profiles.active', 'oracle'
  testLogging {
    events "passed", "skipped", "failed"
    exceptionFormat = 'full'
  }
  doFirst {
    sleep(10000) // Wait for Oracle container to be ready
  }
}

// Docker Compose configuration for PostgreSQL testing
dockerCompose {
  projectName = 'sitmun-backend-core'
  postgres {
    useComposeFiles = ['docker/postgres/test-docker-compose.yml']
    isRequiredBy(project.tasks.testPostgres)
  }
  oracle {
    useComposeFiles = ['docker/oracle/test-docker-compose.yml']
    isRequiredBy(project.tasks.testOracle)
  }
}

// All Database Tests
tasks.register('testAll', Test) {
  group = 'verification'
  description = 'Run tests with both H2 and PostgreSQL databases'
  
  dependsOn testH2, testPostgres
  
  // This task will run both test suites
  testLogging {
    events "passed", "skipped", "failed"
    exceptionFormat = 'full'
  }
}

// Code coverage reporting
jacocoTestReport {
  reports {
    xml.required.set(true)
    html.required.set(true)
  }
}

test.finalizedBy jacocoTestReport

// SonarQube integration
apply from: "$project.rootDir/sonar.gradle"

rootProject.tasks.sonarqube {
  dependsOn(tasks.jacocoTestReport)
}

// Spotless code formatting

spotless {
  java {
    removeUnusedImports()
    googleJavaFormat('1.28.0')
    // importOrder 'java', 'javax', 'org', 'com'
    target '**/*.java'
    targetExclude '**/generated-sources/**'
  }
}

// Axion Release Plugin Configuration
scmVersion {
  ignoreUncommittedChanges.set(true)
  tag {
    prefix.set('sitmun-backend-core')
    versionSeparator.set('/')
    initialVersion({config, position -> '1.0.0'})
  }
  versionIncrementer('incrementPatch')
}

project.version = '1.2.2'

// Git hooks setup
tasks.register('setupGitHooks') {
  group = 'git hooks'
  description = 'Install Git hooks for commit message validation and pre-commit checks'
  def hookDir = new File(project.rootDir, '.git/hooks')
  def commitMsgHook = new File(hookDir, 'commit-msg')
  def preCommitHook = new File(hookDir, 'pre-commit')

  doLast {
    hookDir.mkdirs()

    // Pre-commit hook
    preCommitHook.text = '''#!/bin/sh
            echo "üîç Running pre-commit checks..."
            
            # Code formatting check
            echo "  üìù Checking code formatting..."
            ./gradlew spotlessCheck
            if [ $? -ne 0 ]; then
                echo "‚ùå Code formatting check failed. Run './gradlew spotlessApply' to fix."
                exit 1
            fi
            
            # Tests
            echo "  üß™ Running tests..."
            ./gradlew test
            if [ $? -ne 0 ]; then
                echo "‚ùå Tests failed. Please fix the failing tests."
                exit 1
            fi
            
            # Code coverage check
            echo "  üìä Checking code coverage..."
            ./gradlew jacocoTestReport
            if [ $? -ne 0 ]; then
                echo "‚ùå Code coverage check failed."
                exit 1
            fi
            
            echo "‚úÖ All pre-commit checks passed!"
        '''.stripIndent()
    preCommitHook.setExecutable(true)

    // Commit message hook
    commitMsgHook.text = '''#!/bin/sh
            commit_msg=$(cat $1)
            
            # Conventional commit pattern for SITMUN Backend Core
            pattern="^(feat|fix|docs|style|refactor|test|chore|perf|ci|build)(\\([a-z-]+\\))?: .+"
            
            if ! echo "$commit_msg" | grep -qE "$pattern"; then
                echo "‚ùå Invalid commit message format."
                echo ""
                echo "Expected: <type>(<scope>): <description>"
                echo ""
                echo "Types:"
                echo "  feat     - New feature"
                echo "  fix      - Bug fix"
                echo "  docs     - Documentation changes"
                echo "  style    - Code style changes"
                echo "  refactor - Code refactoring"
                echo "  test     - Test changes"
                echo "  chore    - Maintenance tasks"
                echo "  perf     - Performance improvements"
                echo "  ci       - CI/CD changes"
                echo "  build    - Build system changes"
                echo ""
                echo "Scopes (optional):"
                echo "  auth     - Authentication and authorization"
                echo "  api      - API endpoints and controllers"
                echo "  domain   - Domain entities and business logic"
                echo "  security - Security configuration"
                echo "  config   - Configuration and profiles"
                echo "  test     - Testing framework"
                echo "  build    - Build system and dependencies"
                echo ""
                echo "Examples:"
                echo "  feat(auth): add LDAP authentication support"
                echo "  fix(api): resolve JWT token validation issue"
                echo "  docs: update README with deployment instructions"
                echo "  test: add integration tests for user verification"
                echo "  style: format code with Google Java Format"
                echo "  refactor(domain): improve user entity design"
                echo "  chore: update dependencies to latest versions"
                echo "  perf(api): optimize authentication endpoint"
                echo "  ci: add GitHub Actions workflow"
                echo "  build: update Gradle configuration"
                exit 1
            fi
            
            echo "‚úÖ Commit message format is valid!"
        '''.stripIndent()
    commitMsgHook.setExecutable(true)


    println "‚úÖ Git hooks installed successfully!"
    println "üìã Pre-commit hook: Runs tests, formatting, and security checks"
    println "üìù Commit-msg hook: Validates conventional commit message format"
    println ""
    println "üí° Usage examples:"
    println "  git commit -m \"feat: add tile merging functionality\""
    println "  git commit -m \"fix: resolve memory leak\""
    println "  git commit -m \"docs: update README\""
    println "  git commit -m \"test: add integration tests\""
  }
}

// Task to remove Git hooks
tasks.register('removeGitHooks') {
  group = 'git hooks'
  description = 'Remove Git hooks'
  def hookDir = new File(project.rootDir, '.git/hooks')

  doLast {
    ['pre-commit', 'commit-msg'].each { hookName ->
      def hookFile = new File(hookDir, hookName)
      if (hookFile.exists()) {
        hookFile.delete()
        println "üóëÔ∏è  Removed ${hookName} hook"
      }
    }
    println "‚úÖ Git hooks removed successfully!"
  }
}

// Make setupGitHooks available as a dependency for build
tasks.named('build') {
  dependsOn 'setupGitHooks'
}

