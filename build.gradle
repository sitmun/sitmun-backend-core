import org.springframework.boot.gradle.plugin.SpringBootPlugin

plugins {
  id 'java'
  id 'com.heroku.sdk.heroku-gradle' version '2.0.0'
  id 'jacoco'
  id 'org.sonarqube' version '3.3'

  id 'org.springframework.boot' version '2.7.18'
  id 'io.spring.dependency-management' version '1.1.6'

  id 'org.ajoberstar.git-publish' version '3.0.1'

  id 'com.github.johnrengelman.processes' version '0.5.0'
  id 'org.springdoc.openapi-gradle-plugin' version '1.5.0'

  id 'io.freefair.lombok' version '6.4.3.1'

  id 'org.liquibase.gradle' version '2.2.0'
}

group = 'org.sitmun'

def targetJavaVersion = JavaVersion.VERSION_11
sourceCompatibility = "${targetJavaVersion}"
targetCompatibility = "${targetJavaVersion}"

repositories {
  mavenLocal()
  mavenCentral()
}

dependencyManagement {
  imports {
    mavenBom SpringBootPlugin.BOM_COORDINATES
  }
}

dependencies {
  implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
  implementation 'org.springframework.boot:spring-boot-starter-data-rest'
  implementation 'org.springframework.boot:spring-boot-starter-validation'
  implementation 'org.springframework.boot:spring-boot-starter-security'
  implementation 'org.springframework.boot:spring-boot-starter-actuator'

  implementation 'org.springframework.ldap:spring-ldap-core'
  implementation 'org.springframework.security:spring-security-ldap'
  testImplementation 'com.unboundid:unboundid-ldapsdk'

  implementation 'org.postgresql:postgresql'
  implementation 'com.oracle.database.jdbc:ojdbc11-production'

  testImplementation 'org.hamcrest:hamcrest'

  implementation "com.google.guava:guava:${guava_version}"

  implementation "com.querydsl:querydsl-jpa:${querydls_version}"

  implementation platform("com.squareup.okhttp3:okhttp-bom:${okhttp_version}")
  implementation 'com.squareup.okhttp3:okhttp'
  implementation 'com.squareup.okhttp3:logging-interceptor'

  implementation "org.json:json:${json_version}"
  implementation "io.jsonwebtoken:jjwt-api:${jjwt_version}"
  implementation "io.jsonwebtoken:jjwt-impl:${jjwt_version}"
  implementation "io.jsonwebtoken:jjwt-jackson:${jjwt_version}"

  implementation "org.springdoc:springdoc-openapi-common:${springdoc_openapi_version}"
  implementation "org.springdoc:springdoc-openapi-ui:${springdoc_openapi_version}"

  implementation "org.mapstruct:mapstruct:${mapstruct_version}"

  implementation "org.apache.commons:commons-lang3:${commons_lang3_version}"

  implementation 'org.liquibase:liquibase-core'
  implementation "com.mattbertolini:liquibase-slf4j:${liquibase_slf4j_version}"

  annotationProcessor 'javax.annotation:javax.annotation-api'
  annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'
  annotationProcessor "com.querydsl:querydsl-apt:${querydls_version}:jpa"
  annotationProcessor 'javax.persistence:javax.persistence-api'
  annotationProcessor "org.mapstruct:mapstruct-processor:${mapstruct_version}"

  testImplementation('org.springframework.boot:spring-boot-starter-test') {
    exclude group: 'com.vaadin.external.google', module: 'android-json'
  }
  testImplementation 'org.springframework.security:spring-security-test'
  testImplementation 'com.h2database:h2'
  compileOnly 'org.projectlombok:lombok:1.18.36'
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Stage task:
// - build app module
// - do not run tests
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

tasks.register('stage') {
  dependsOn ':processResources', ':bootJar'
  it.doLast {
    copy {
      from "build/libs/sitmun-backend-core-${version}.jar"
      into "."
      rename "sitmun-backend-core-${version}.jar", "sitmun.jar"
    }
  }
}

gradle.taskGraph.whenReady { taskGraph ->
  if (taskGraph.hasTask(stage)) {
    subprojects {
      test.enabled = false
    }
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Heroku deployment:
// - contributes the task deployHeroku
// - expects the stage task has been successfully executed
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

heroku {
  def procFile = ["web": "java -Dserver.port=\$PORT \$JAVA_OPTS -cp \"sitmun.jar:env/heroku/resources/config\" org.springframework.boot.loader.JarLauncher"]
  appName = "sitmun-backend-core"
  includes = ["sitmun.jar"]
  includeBuildDir = false
  processTypes(procFile)
}

tasks.named("deployHeroku") {
  it.dependsOn 'stage'
  it.doLast {
    delete "sitmun.jar"
  }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// QA
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

subprojects {
  apply plugin: 'org.sonarqube'

  tasks.withType(Test).configureEach {
    useJUnitPlatform()
    maxHeapSize = '1G'
  }
}

apply from: "$project.rootDir/sonar.gradle"


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Run as local
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

tasks.register('herokuDevLocal', JavaExec) {
  dependsOn 'stage'
  group = "Run"
  description = "Run as local the Heroku deployment"
  classpath = files("build/libs/sitmun-backend-core-${version}.jar")
}

tasks.withType(Test).configureEach {
  useJUnitPlatform()
}

compileJava.inputs.files(processResources)

jacocoTestReport {
  reports {
    xml.required.set(true)
  }
}

test.finalizedBy jacocoTestReport

tasks.register("codeCoverageReport", JacocoReport) {
  jacocoClasspath = project.configurations.jacocoAnt
  subprojects { subproject ->
    subproject.plugins.withType(JacocoPlugin).configureEach {
      subproject.tasks.matching({ t -> t.extensions.findByType(JacocoTaskExtension) }).configureEach { testTask ->
        if (testTask.extensions.getByType(JacocoTaskExtension).isEnabled()) {
          sourceSets subproject.sourceSets.main
          executionData(testTask)
        } else {
          logger.warn('Jacoco extension is disabled for test task \'{}\' in project \'{}\'. this test task will be excluded from jacoco report.', testTask.getName(), subproject.getName())
        }
      }
      subproject.tasks.matching({ t -> t.extensions.findByType(JacocoTaskExtension) }).forEach {
        rootProject.tasks.codeCoverageReport.dependsOn(it)
      }
    }
  }

}

rootProject.tasks.sonarqube {
  dependsOn(tasks.codeCoverageReport)
}

